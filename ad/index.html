/**
 * AD Channel Sync
 * Enables two-way realtime sync between main app and AD viewers
 * 
 * Features:
 * - Row reordering sync
 * - Duration change sync  
 * - Sharpie (completion) sync
 * - Cell formatting sync (colors, fonts, alignment, etc)
 * - Presence tracking
 */

(function() {
  'use strict';
  
  const ADChannelSync = {
    channel: null,
    channelCode: null,
    isActive: false,
    connectedUsers: [],
    
    /**
     * Start AD sync for a channel
     */
    async start(channelCode) {
      if (this.isActive && this.channelCode === channelCode) {
        console.log('[ADSync] Already active for this channel');
        return true;
      }
      
      // Stop any existing sync (internal cleanup - don't notify viewers)
      this.stop(false);
      
      if (!window.SupabaseAPI?.client) {
        console.error('[ADSync] Supabase client not available');
        return false;
      }
      
      this.channelCode = channelCode;
      const roomName = 'ad-sync-' + channelCode.toUpperCase();
      
      console.log('[ADSync] Starting sync for room:', roomName);
      
      const supabase = window.SupabaseAPI.client();
      
      this.channel = supabase.channel(roomName, {
        config: {
          broadcast: { self: false }
        }
      });
      
      // Listen for events from AD viewers
      this.channel
        .on('broadcast', { event: 'row-reorder' }, (payload) => this.handleRowReorder(payload))
        .on('broadcast', { event: 'duration-change' }, (payload) => this.handleDurationChange(payload))
        .on('broadcast', { event: 'sharpie-toggle' }, (payload) => this.handleSharpieToggle(payload))
        .on('broadcast', { event: 'sharpie-visibility' }, (payload) => this.handleSharpieVisibility(payload))
        .on('broadcast', { event: 'cell-format' }, (payload) => this.handleCellFormatting(payload))
        .on('broadcast', { event: 'row-format' }, (payload) => this.handleRowFormatting(payload))
        .on('broadcast', { event: 'request-sync' }, () => {
          this.broadcastFullSync();
          // Also send current live status
          this.channel.send({
            type: 'broadcast',
            event: 'sync-status',
            payload: { live: true }
          });
        })
        .on('presence', { event: 'sync' }, () => this.handlePresenceSync())
        .subscribe((status) => {
          console.log('[ADSync] Subscription status:', status);
          
          if (status === 'SUBSCRIBED') {
            this.isActive = true;
            
            // Persist AD sync state for reconnect after refresh
            localStorage.setItem('adSyncChannelCode', channelCode);
            
            // Add visual indicator to main app
            document.body.classList.add('ad-sync-active');
            
            // Track our presence
            this.channel.track({
              user: 'Producer-' + Math.random().toString(36).substr(2, 4),
              role: 'producer'
            });
            
            // Send current state to any connected AD viewers
            this.broadcastFullSync();
            
            // Notify AD viewer that sync is LIVE
            this.channel.send({
              type: 'broadcast',
              event: 'sync-status',
              payload: { live: true }
            });
            
            this.notifyStatusChange('connected');
          } else if (status === 'CLOSED' || status === 'CHANNEL_ERROR') {
            this.isActive = false;
            document.body.classList.remove('ad-sync-active');
            this.notifyStatusChange('disconnected');
          }
        });
      
      return true;
    },
    
    /**
     * Stop AD sync
     * @param {boolean} notifyViewers - Whether to notify AD viewers of status change (default: true)
     */
    stop(notifyViewers = true) {
      if (this.channel) {
        console.log('[ADSync] Stopping sync');
        
        // Only notify AD viewer when explicitly stopping (not internal cleanup)
        if (notifyViewers) {
          this.channel.send({
            type: 'broadcast',
            event: 'sync-status',
            payload: { live: false }
          });
        }
        
        this.channel.unsubscribe();
        this.channel = null;
      }
      this.channelCode = null;
      this.isActive = false;
      this.connectedUsers = [];
      
      // Clear persisted state
      localStorage.removeItem('adSyncChannelCode');
      
      document.body.classList.remove('ad-sync-active');
      
      // Explicitly clear table glow
      const table = document.querySelector('.schedule-scroll table.schedule, .schedule-scroll #scheduleTable, #scheduleTable');
      if (table) {
        table.style.boxShadow = '';
      }
      
      this.notifyStatusChange('disconnected');
    },
    
    /**
     * Handle row reorder from AD viewer
     */
    handleRowReorder(payload) {
      console.log('[ADSync] handleRowReorder received:', payload);
      const { order, source } = payload.payload || payload;
      
      // Only process if from AD viewer
      if (source !== 'ad') {
        console.log('[ADSync] Ignoring row reorder - source is', source);
        return;
      }
      
      console.log('[ADSync] Processing row reorder from AD:', order);
      
      // Get current day's rows
      const state = window.readState?.();
      if (!state) return;
      
      const currentDayId = state.activeDayId;
      const day = state.days?.find(d => d.id === currentDayId);
      if (!day || !day.rows) return;
      
      // Reorder rows in state to match the new order
      const rowMap = new Map(day.rows.map(r => [r.id, r]));
      const newRows = [];
      
      order.forEach(rowId => {
        const row = rowMap.get(rowId);
        if (row) {
          newRows.push(row);
          rowMap.delete(rowId);
        }
      });
      
      // Add any rows that weren't in the order (shouldn't happen, but safety)
      rowMap.forEach(row => newRows.push(row));
      
      // Update state
      day.rows = newRows;
      window.writeState?.(state);
      
      // Move DOM rows directly instead of rebuilding (much faster)
      const tbody = document.querySelector('.schedule tbody');
      if (tbody) {
        order.forEach(rowId => {
          const tr = document.getElementById(rowId);
          if (tr) {
            tbody.appendChild(tr);
            // If this is a SUB row, also move its subchildren
            if (tr.dataset.type === 'SUB') {
              const subchildren = tbody.querySelectorAll(`tr.subchild[data-parent="${rowId}"]`);
              subchildren.forEach(child => tbody.appendChild(child));
            }
          }
        });
      }
      
      // Renumber and recalculate
      if (window.renumber) window.renumber();
      if (window.recalc) window.recalc();
      
      // Update sharpie lines
      if (typeof SharpieManager !== 'undefined' && SharpieManager.updateAllLinePositions) {
        SharpieManager.updateAllLinePositions();
      }
      
      // Show notification
      this.showNotification('Row order updated from AD');
    },
    
    /**
     * Handle duration change from AD viewer
     */
    handleDurationChange(payload) {
      console.log('[ADSync] handleDurationChange received:', payload);
      // Handle both payload.payload and direct payload
      const data = payload.payload || payload;
      const { rowId, duration, source } = data;
      
      if (source !== 'ad') {
        console.log('[ADSync] Ignoring duration change - source is', source);
        return;
      }
      
      console.log('[ADSync] Processing duration change from AD:', rowId, duration);
      
      const state = window.readState?.();
      if (!state) return;
      
      const currentDayId = state.activeDayId;
      const day = state.days?.find(d => d.id === currentDayId);
      if (!day || !day.rows) return;
      
      // Find and update the row
      const row = day.rows.find(r => r.id === rowId);
      if (row) {
        row.duration = duration;
        window.writeState?.(state);
        
        // Update the DOM
        const tr = document.getElementById(rowId);
        if (tr) {
          const durationCell = tr.querySelector('td[data-key="duration"]');
          if (durationCell) {
            // Find the input or just update the cell
            const input = durationCell.querySelector('input');
            if (input) {
              input.value = duration;
            } else {
              durationCell.textContent = duration;
            }
          }
        }
        
        // Recalculate times
        if (window.recalc) {
          window.recalc();
        }
        
        this.showNotification('Duration updated from AD');
      }
    },
    
    /**
     * Handle sharpie toggle from AD viewer
     */
    handleSharpieToggle(payload) {
      console.log('[ADSync] handleSharpieToggle received:', payload);
      const data = payload.payload || payload;
      const { rowId, marked, source } = data;
      
      if (source !== 'ad') {
        console.log('[ADSync] Ignoring sharpie toggle - source is', source);
        return;
      }
      
      console.log('[ADSync] Processing sharpie toggle from AD:', rowId, marked);
      
      // Update via SharpieManager
      if (window.SharpieManager) {
        if (marked) {
          window.SharpieManager.mark(rowId);
        } else {
          window.SharpieManager.unmark(rowId);
        }
      }
      
      // Also update the row data for persistence
      const state = window.readState?.();
      if (state) {
        const currentDayId = state.activeDayId;
        const day = state.days?.find(d => d.id === currentDayId);
        if (day && day.rows) {
          const row = day.rows.find(r => r.id === rowId);
          if (row) {
            row.completed = marked;
            window.writeState?.(state);
          }
        }
      }
      
      this.showNotification(marked ? 'Row marked complete from AD' : 'Row unmarked from AD');
    },
    
    /**
     * Handle sharpie visibility from AD viewer
     */
    handleSharpieVisibility(payload) {
      console.log('[ADSync] handleSharpieVisibility received:', payload);
      const data = payload.payload || payload;
      const { hidden, source } = data;
      
      if (source !== 'ad') {
        console.log('[ADSync] Ignoring sharpie visibility - source is', source);
        return;
      }
      
      console.log('[ADSync] Processing sharpie visibility from AD:', hidden);
      
      // Toggle sharpie visibility in main app
      document.body.classList.toggle('sharpie-lines-hidden', hidden);
      
      // Update master sharpie button state if exists
      const masterBtn = document.querySelector('.master-sharpie-toggle');
      if (masterBtn) {
        masterBtn.classList.toggle('lines-hidden', hidden);
      }
    },
    
    /**
     * Handle presence sync
     */
    handlePresenceSync() {
      if (!this.channel) return;
      
      const state = this.channel.presenceState();
      this.connectedUsers = Object.values(state).flat();
      
      console.log('[ADSync] Connected users:', this.connectedUsers);
      
      // Notify UI
      window.dispatchEvent(new CustomEvent('ad-presence-changed', {
        detail: { users: this.connectedUsers }
      }));
    },
    
    /**
     * Broadcast row reorder to AD viewers
     */
    broadcastRowReorder(newOrder) {
      if (!this.channel || !this.isActive) return;
      
      console.log('[ADSync] Broadcasting row reorder to AD');
      
      this.channel.send({
        type: 'broadcast',
        event: 'row-reorder',
        payload: { order: newOrder, source: 'producer' }
      });
    },
    
    /**
     * Broadcast duration change to AD viewers
     */
    broadcastDurationChange(rowId, duration) {
      if (!this.channel || !this.isActive) return;
      
      console.log('[ADSync] Broadcasting duration change to AD');
      
      this.channel.send({
        type: 'broadcast',
        event: 'duration-change',
        payload: { rowId, duration, source: 'producer' }
      });
    },
    
    /**
     * Broadcast sharpie toggle to AD viewers
     */
    broadcastSharpieToggle(rowId, marked) {
      if (!this.channel || !this.isActive) return;
      
      console.log('[ADSync] Broadcasting sharpie toggle to AD');
      
      this.channel.send({
        type: 'broadcast',
        event: 'sharpie-toggle',
        payload: { rowId, marked, source: 'producer' }
      });
    },
    
    /**
     * Broadcast sharpie visibility to AD viewers
     */
    broadcastSharpieVisibility(hidden) {
      if (!this.channel || !this.isActive) return;
      
      console.log('[ADSync] Broadcasting sharpie visibility to AD');
      
      this.channel.send({
        type: 'broadcast',
        event: 'sharpie-visibility',
        payload: { hidden, source: 'producer' }
      });
    },
    
    /**
     * Capture and broadcast cell formatting changes
     * Called when user changes color, font, alignment, etc on a cell
     */
    broadcastCellFormatting(rowId, columnKey, formatting) {
      if (!this.channel || !this.isActive) return;
      
      console.log('[ADSync] Broadcasting cell formatting:', rowId, columnKey, formatting);
      
      this.channel.send({
        type: 'broadcast',
        event: 'cell-format',
        payload: { rowId, columnKey, formatting, source: 'producer' }
      });
    },
    
    /**
     * Broadcast entire row formatting (all cells)
     */
    broadcastRowFormatting(rowId, rowFormatting) {
      if (!this.channel || !this.isActive) return;
      
      console.log('[ADSync] Broadcasting row formatting:', rowId);
      
      this.channel.send({
        type: 'broadcast',
        event: 'row-format',
        payload: { rowId, formatting: rowFormatting, source: 'producer' }
      });
    },
    
    /**
     * Handle cell format change from AD viewer
     */
    handleCellFormatting(payload) {
      console.log('[ADSync] handleCellFormatting received:', payload);
      const data = payload.payload || payload;
      const { rowId, columnKey, formatting, source } = data;
      
      if (source !== 'ad') {
        console.log('[ADSync] Ignoring cell format - source is', source);
        return;
      }
      
      console.log('[ADSync] Processing cell formatting from AD:', rowId, columnKey);
      
      // Find and update the cell
      const tr = document.getElementById(rowId);
      if (tr) {
        const cell = tr.querySelector(`td[data-key="${columnKey}"]`);
        if (cell && window.applyFormatting) {
          window.applyFormatting(cell, formatting);
          
          // Save to state
          const state = window.readState?.();
          if (state) {
            const currentDayId = state.activeDayId;
            const day = state.days?.find(d => d.id === currentDayId);
            if (day && day.rows) {
              const row = day.rows.find(r => r.id === rowId);
              if (row) {
                if (!row.cellFormatting) row.cellFormatting = {};
                row.cellFormatting[columnKey] = { ...row.cellFormatting[columnKey], ...formatting };
                window.writeState?.(state);
              }
            }
          }
          
          this.showNotification('Formatting updated from AD');
        }
      }
    },
    
    /**
     * Handle row format change from AD viewer
     */
    handleRowFormatting(payload) {
      console.log('[ADSync] handleRowFormatting received:', payload);
      const data = payload.payload || payload;
      const { rowId, formatting, source } = data;
      
      if (source !== 'ad') {
        console.log('[ADSync] Ignoring row format - source is', source);
        return;
      }
      
      console.log('[ADSync] Processing row formatting from AD:', rowId);
      
      // Find and update all cells in row
      const tr = document.getElementById(rowId);
      if (tr) {
        const cells = tr.querySelectorAll('td[data-key]:not([data-key="drag"]):not([data-key="actions"])');
        cells.forEach(cell => {
          const key = cell.dataset.key;
          const cellFormat = formatting[key];
          if (cellFormat && window.applyFormatting) {
            window.applyFormatting(cell, cellFormat);
          }
        });
        
        // Save to state
        const state = window.readState?.();
        if (state) {
          const currentDayId = state.activeDayId;
          const day = state.days?.find(d => d.id === currentDayId);
          if (day && day.rows) {
            const row = day.rows.find(r => r.id === rowId);
            if (row) {
              row.cellFormatting = { ...row.cellFormatting, ...formatting };
              window.writeState?.(state);
            }
          }
        }
        
        this.showNotification('Row formatting updated from AD');
      }
    },
    
    /**
     * Broadcast column resize to AD viewers
     */
    broadcastColumnResize(key, width) {
      if (!this.channel || !this.isActive) return;
      
      this.channel.send({
        type: 'broadcast',
        event: 'column-resize',
        payload: { key, width, source: 'producer' }
      });
    },
    
    /**
     * Broadcast row resize to AD viewers
     */
    broadcastRowResize(rowId, height) {
      if (!this.channel || !this.isActive) return;
      
      this.channel.send({
        type: 'broadcast',
        event: 'row-resize',
        payload: { rowId, height, source: 'producer' }
      });
    },
    
    /**
     * Broadcast full state sync to AD viewers
     */
    broadcastFullSync() {
      if (!this.channel || !this.isActive) return;
      
      console.log('[ADSync] Broadcasting full sync to AD');
      
      const state = window.readState?.();
      if (!state) return;
      
      const currentDayId = state.activeDayId;
      const day = state.days?.find(d => d.id === currentDayId);
      if (!day || !day.rows) return;
      
      // Get row order
      const order = day.rows.map(r => r.id);
      
      // Get marked rows
      const sharpieRows = day.rows
        .filter(r => r.completed)
        .map(r => r.id);
      
      // Get sharpie lines hidden state
      const linesHidden = document.body.classList.contains('sharpie-lines-hidden');
      
      this.channel.send({
        type: 'broadcast',
        event: 'full-sync',
        payload: { 
          order, 
          sharpieRows,
          linesHidden,
          source: 'producer' 
        }
      });
    },
    
    /**
     * Show a notification
     */
    showNotification(message) {
      // Use alert system if available
      if (window.AlertSystem?.show) {
        window.AlertSystem.show(message, 'info', 2000);
      } else {
        console.log('[ADSync]', message);
      }
    },
    
    /**
     * Notify status change
     */
    notifyStatusChange(status) {
      window.dispatchEvent(new CustomEvent('ad-sync-status-changed', {
        detail: { status, channelCode: this.channelCode }
      }));
    },
    
    /**
     * Get current status
     */
    getStatus() {
      return {
        isActive: this.isActive,
        channelCode: this.channelCode,
        connectedUsers: this.connectedUsers
      };
    }
  };
  
  // Hook into existing systems to broadcast changes
  
  // Hook into row reordering (after drag-drop)
  const originalDragEnd = window.onRowDragEnd;
  window.onRowDragEnd = function(...args) {
    if (originalDragEnd) originalDragEnd.apply(this, args);
    
    // Broadcast new order if AD sync is active
    if (ADChannelSync.isActive) {
      const state = window.readState?.();
      if (state) {
        const day = state.days?.find(d => d.id === state.activeDayId);
        if (day && day.rows) {
          ADChannelSync.broadcastRowReorder(day.rows.map(r => r.id));
        }
      }
    }
  };
  
  // Hook into duration changes
  const originalDurationChange = window.onDurationChange;
  window.onDurationChange = function(rowId, duration, ...args) {
    if (originalDurationChange) originalDurationChange.apply(this, [rowId, duration, ...args]);
    
    if (ADChannelSync.isActive) {
      ADChannelSync.broadcastDurationChange(rowId, duration);
    }
  };
  
  // Hook into SharpieManager
  if (window.SharpieManager) {
    const originalMark = window.SharpieManager.mark.bind(window.SharpieManager);
    const originalUnmark = window.SharpieManager.unmark.bind(window.SharpieManager);
    
    window.SharpieManager.mark = function(rowId) {
      originalMark(rowId);
      if (ADChannelSync.isActive) {
        ADChannelSync.broadcastSharpieToggle(rowId, true);
      }
    };
    
    window.SharpieManager.unmark = function(rowId) {
      originalUnmark(rowId);
      if (ADChannelSync.isActive) {
        ADChannelSync.broadcastSharpieToggle(rowId, false);
      }
    };
  }
  
  // Export globally
  window.ADChannelSync = ADChannelSync;
  
  // Auto-reconnect if there was an active AD sync before refresh
  function tryAutoReconnect() {
    const savedChannelCode = localStorage.getItem('adSyncChannelCode');
    if (savedChannelCode && window.SupabaseAPI?.client) {
      console.log('[ADSync] Auto-reconnecting to:', savedChannelCode);
      ADChannelSync.start(savedChannelCode);
    }
  }
  
  // Wait for auth to be ready before trying to reconnect
  window.addEventListener('authStateChanged', () => {
    // Small delay to ensure Supabase client is fully ready
    setTimeout(tryAutoReconnect, 500);
  });
  
  // Also try on subscriptionChanged in case auth was already ready
  window.addEventListener('subscriptionChanged', () => {
    if (!ADChannelSync.isActive) {
      tryAutoReconnect();
    }
  });
  
  console.log('[ADSync] Module loaded');
})();
