<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SKEDULER AD</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    :root {
      --bg: #0a0e13;
      --panel: #161b22;
      --muted: #9ca3af;
      --text: #f9fafb;
      --accent: #3b82f6;
      --row: #0d1117;
      --rowAlt: #1a2129;
      --border: #374151;
      --ad-purple: #a371f7;
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    /* ===== HEADER ===== */
    .header {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      padding: 12px 16px;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      min-height: 48px;
      flex-shrink: 0;
    }
    
    .header-left { display: flex; align-items: center; gap: 8px; justify-self: start; }
    .channel-label { font-size: 14px; color: var(--text); }
    .channel-label span { color: var(--muted); }
    .header-center { justify-self: center; display: flex; align-items: center; gap: 6px; }
    .header-right { display: flex; align-items: center; gap: 12px; justify-self: end; }
    
    .live-badge { display: flex; align-items: center; gap: 6px; font-size: 11px; font-weight: 600; letter-spacing: 0.5px; height: 28px; }
    .live-dot { width: 12px; height: 12px; border-radius: 50%; background: var(--muted); }
    .live-badge.live .live-dot { background: var(--ad-purple); animation: pulse 1.5s ease-in-out infinite; }
    .live-badge.live .live-text { color: var(--ad-purple); text-transform: uppercase; }
    .live-badge.manual .live-dot { background: var(--muted); }
    .live-badge.manual .live-text { display: none; }
    
    .header-progress-btn {
      width: 28px; height: 28px; padding: 4px; border-radius: 4px; border: none;
      background: var(--ad-purple); cursor: pointer;
      display: flex; align-items: center; justify-content: center;
    }
    .header-progress-btn:hover { filter: brightness(1.1); }
    .header-progress-btn.lines-hidden { background: var(--ad-purple); }
    .header-progress-btn:not(.lines-hidden) { background: #f44336; }
    
    @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.7; transform: scale(0.9); } }
    
    .header-logo { display: flex; align-items: center; gap: 6px; font-size: 11px; font-weight: 700; letter-spacing: 2px; color: var(--text); }
    .ad-badge { background: var(--ad-purple); color: #fff; font-size: 9px; font-weight: 700; padding: 2px 6px; border-radius: 3px; letter-spacing: 1px; }
    .header-logo svg { width: 20px; height: 20px; }
    
    /* ===== MAIN CONTENT ===== */
    .main-content { flex: 1; overflow: hidden; display: flex; flex-direction: column; }
    #schedule-container { flex: 1; overflow: hidden; position: relative; }
    .schedule-scroll { position: relative; width: 100%; height: 100%; overflow: auto; padding: 16px; display: flex; flex-direction: column; align-items: center; }
    
    /* Wrapper to keep header and table together */
    .schedule-scroll > * {
      flex-shrink: 0;
    }
    
    /* ===== TABLE - Purple border glow ===== */
    #scheduleScroll table,
    table.schedule {
      border-collapse: collapse;
      width: auto;
      table-layout: fixed;
      border-radius: 8px;
      box-shadow: 0 0 0 2px var(--ad-purple), 0 0 20px rgba(163, 113, 247, 0.3);
    }
    
    /* Round corners on corner cells - with white borders */
    #scheduleScroll table thead tr:first-child th:first-child {
      border-top-left-radius: 8px;
      overflow: hidden;
      background: #4b5563;
    }
    #scheduleScroll table thead tr:first-child th:last-child {
      border-top-right-radius: 8px;
      overflow: hidden;
      background: #4b5563;
    }
    #scheduleScroll table tbody tr:last-child td:first-child {
      border-bottom-left-radius: 8px;
      overflow: hidden;
    }
    #scheduleScroll table tbody tr:last-child td:last-child {
      border-bottom-right-radius: 8px;
      overflow: hidden;
    }
    
    /* Bottom corner cells need the cell-bg to also have rounded corners */
    #scheduleScroll table tbody tr:last-child td:first-child .cell-bg {
      border-bottom-left-radius: 6px;
    }
    #scheduleScroll table tbody tr:last-child td:last-child .cell-bg {
      border-bottom-right-radius: 6px;
    }
    
    #scheduleScroll table thead th {
      position: sticky;
      top: 0;
      z-index: 100;
      background: #141920;
      font-weight: 600;
      color: var(--text);
    }
    
    /* Override for drag/action header cells */
    #scheduleScroll table thead th[data-key="drag"],
    #scheduleScroll table thead th[data-key="actions"] {
      background: #4b5563;
      border: 2px solid #ffffff;
    }
    
    /* ===== DRAG & ACTION COLUMNS ===== */
    td[data-key="drag"],
    td[data-key="actions"] {
      position: relative;
      padding: 0 !important;
      width: 60px;
      min-width: 60px;
      max-width: 60px;
    }
    
    th[data-key="drag"],
    th[data-key="actions"] {
      width: 60px;
      min-width: 60px;
      max-width: 60px;
      background: #4b5563;
    }
    
    /* White borders on drag/action columns - specific sides to avoid doubling */
    th[data-key="drag"],
    td[data-key="drag"] {
      border-left: 2px solid #ffffff;
      border-top: 2px solid #ffffff;
      border-bottom: 2px solid #ffffff;
      border-right: 2px solid #ffffff;
    }
    
    th[data-key="actions"],
    td[data-key="actions"] {
      border-left: 2px solid #ffffff;
      border-top: 2px solid #ffffff;
      border-bottom: 2px solid #ffffff;
      border-right: 2px solid #ffffff;
    }
    
    /* Remove internal horizontal borders to prevent doubling */
    tbody td[data-key="drag"],
    tbody td[data-key="actions"] {
      border-top: none;
    }
    
    /* Absolute div covers row background */
    .cell-bg {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #4b5563;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    td[data-key="drag"] { cursor: grab; }
    td[data-key="drag"]:active { cursor: grabbing; }
    
    .drag-dots {
      display: inline-block;
      width: 12px; height: 12px;
      background-image: 
        radial-gradient(circle, #9ca3af 1px, transparent 1px),
        radial-gradient(circle, #9ca3af 1px, transparent 1px),
        radial-gradient(circle, #9ca3af 1px, transparent 1px),
        radial-gradient(circle, #9ca3af 1px, transparent 1px),
        radial-gradient(circle, #9ca3af 1px, transparent 1px),
        radial-gradient(circle, #9ca3af 1px, transparent 1px),
        radial-gradient(circle, #9ca3af 1px, transparent 1px),
        radial-gradient(circle, #9ca3af 1px, transparent 1px),
        radial-gradient(circle, #9ca3af 1px, transparent 1px);
      background-size: 2px 2px;
      background-position: 0 0, 5px 0, 10px 0, 0 5px, 5px 5px, 10px 5px, 0 10px, 5px 10px, 10px 10px;
      background-repeat: no-repeat;
    }
    
    button.sharpie {
      margin: 0; padding: 0;
      width: 22px; height: 22px;
      min-width: 22px; min-height: 22px;
      display: inline-flex; align-items: center; justify-content: center;
      background: white; color: var(--accent);
      border: 1px solid #e0e0e0; border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    button.sharpie svg { width: 14px; height: 14px; }
    button.sharpie.active { background: #f44336; color: white; border-color: #d32f2f; }
    
    /* ===== DRAGGING ===== */
    tr.dragging { opacity: 0.6; outline: 2px dashed var(--accent); }
    
    /* ===== SHARPIE LINES ===== */
    .sharpie-line-element {
      position: absolute;
      height: 4px;
      background: #f44336;
      pointer-events: none;
      z-index: 500;
    }
    body.sharpie-lines-hidden .sharpie-line-element { display: none; }
    
    /* ===== DURATION POPUP ===== */
    .duration-popup {
      position: fixed;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 10000;
      display: none;
    }
    .duration-popup.show { display: block; }
    .duration-popup input {
      width: 80px; padding: 6px 8px;
      border: 1px solid var(--border); border-radius: 4px;
      background: var(--bg); color: var(--text);
      font-size: 14px; text-align: center;
    }
    
    /* ===== SCHEDULE HEADER IMAGE ===== */
    .header-image {
      text-align: center;
      margin-bottom: 12px;
    }
    
    .header-image img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 0 auto;
    }
    
    /* Header design container - match table width */
    .header-design-container {
      width: 100%;
      margin-bottom: 12px;
    }
    
    .header-design-container > div {
      margin: 0 auto;
    }
    
    /* ===== TAG PILLS ===== */
    .tagsBox {
      position: absolute;
      inset: 0;
      display: flex;
      pointer-events: none;
    }
    
    .tags-pills {
      flex: 1;
      display: flex;
      flex-wrap: wrap;
      gap: 3px;
      padding: 4px;
      position: relative;
      z-index: 11;
      pointer-events: none;
      align-items: flex-start;
      align-content: flex-start;
      justify-content: flex-start;
    }
    
    .tag-pill {
      background: var(--panel, #ffffff);
      color: var(--text, #111827);
      padding: 2px 6px 2px 2px;
      border-radius: 999px;
      border: 1px solid #94a3b8;
      display: inline-flex;
      align-items: center;
      gap: 3px;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      font-size: 9px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      position: relative;
      box-sizing: border-box;
      white-space: nowrap;
      flex: 0 0 auto;
    }
    
    .tag-pill.image-tag img {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      object-fit: cover;
    }
    
    /* Vertical alignment for tags cells */
    td[data-valign="top"] .tags-pills { align-items: flex-start; align-content: flex-start; }
    td[data-valign="middle"] .tags-pills { align-items: center; align-content: center; }
    td[data-valign="bottom"] .tags-pills { align-items: flex-end; align-content: flex-end; }
    /* Horizontal alignment for tags cells */
    td[data-align="left"] .tags-pills { justify-content: flex-start; }
    td[data-align="center"] .tags-pills { justify-content: center; }
    td[data-align="right"] .tags-pills { justify-content: flex-end; }
    
    .tag-pill .tag-dummy-circle {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: inline-block;
      background: transparent;
    }
    
    .tag-pill.minor-tag {
      border: 2px solid #dc2626;
      box-shadow: 0 0 0 1px rgba(220, 38, 38, 0.3);
    }
    
    .tag-pill .tag-x {
      display: none;
    }
    
    /* ===== FOOTER ===== */
    .footer {
      text-align: center; padding: 8px;
      font-size: 11px; color: var(--muted);
      background: var(--panel);
      border-top: 1px solid var(--border);
    }
  </style>
  <!-- v17.0 - Added row-times handler, reconnection logic, heartbeat -->
</head>
<body>
  <div class="header">
    <div class="header-left">
      <div class="channel-label">
        <span>Channel:</span> <strong id="channelName">Loading...</strong>
      </div>
    </div>
    <div class="header-center">
      <div class="header-logo">
        <span>SKEDULER</span>
        <span class="ad-badge">AD</span>
        <svg viewBox="195 40 100 130"><g transform="rotate(45 245 96)"><path fill="#dd2222" d="m230,66l0,-35q0,-15 12,-21q3,-2 6,0q12,6 12,21l0,35l-30,0z"/><path fill="#e0e0e0" d="m231.5,66l0,75q0,15 6.5,25l14,0q6.5,-10 6.5,-25l0,-75l-27,0z"/><path fill="#bb1111" d="m238,166q-2,10 7,25q9,-15 7,-25l-14,0z"/></g></svg>
      </div>
    </div>
    <div class="header-right">
      <div class="live-badge manual" id="liveBadge">
        <span class="live-text" id="liveText">LIVE</span>
        <span class="live-dot"></span>
      </div>
      <button class="header-progress-btn" id="progressBtn" title="Toggle Progress" onclick="document.body.classList.toggle('sharpie-lines-hidden');this.classList.toggle('lines-hidden');localStorage.setItem('ad-sharpie-hidden', document.body.classList.contains('sharpie-lines-hidden'));">
        <svg width="18" height="18" viewBox="195 40 100 130"><g transform="rotate(45 245 96)"><path fill="#dd2222" d="m230,66l0,-35q0,-15 12,-21q3,-2 6,0q12,6 12,21l0,35l-30,0z"/><path fill="#e0e0e0" d="m231.5,66l0,75q0,15 6.5,25l14,0q6.5,-10 6.5,-25l0,-75l-27,0z"/><path fill="#bb1111" d="m238,166q-2,10 7,25q9,-15 7,-25l-14,0z"/></g></svg>
      </button>
    </div>
  </div>
  
  <div class="main-content">
    <div id="schedule-container">
      <div class="schedule-scroll" id="scheduleScroll"></div>
    </div>
  </div>
  
  <div class="footer" id="footer">Waiting for connection...</div>
  
  <div class="duration-popup" id="durationPopup">
    <input type="text" id="durationInput" placeholder="0:30">
  </div>

<script>
(function() {
  'use strict';
  
  const SUPABASE_URL = 'https://qcnepxcqilqrhayzhlfa.supabase.co';
  const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFjbmVweGNxaWxxcmhheXpobGZhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI0NTgwMjYsImV4cCI6MjA3ODAzNDAyNn0.Gz7wvMgtu-UtCqw-5MF9s-T-pk-eo2TSw7zOtedWozk';
  
  let supabase = null;
  let channel = null;
  let channelCode = null;
  let draggingRow = null;
  let markedRows = new Set();
  let linesHidden = false;
  let isLiveMode = false;

  // Reconnection state
  let reconnectAttempts = 0;
  let reconnectTimer = null;
  let heartbeatTimer = null;
  let lastHeartbeat = Date.now();
  const MAX_RECONNECT_ATTEMPTS = 10;
  const HEARTBEAT_INTERVAL = 30000; // 30 seconds
  const HEARTBEAT_TIMEOUT = 45000; // 45 seconds without response = reconnect
  
  async function init() {
    // Restore sharpie visibility state
    if (localStorage.getItem('ad-sharpie-hidden') === 'true') {
      document.body.classList.add('sharpie-lines-hidden');
      document.getElementById('progressBtn')?.classList.add('lines-hidden');
    }
    
    const params = new URLSearchParams(window.location.search);
    channelCode = params.get('c');
    
    if (!channelCode) {
      document.getElementById('channelName').textContent = 'No channel code';
      document.getElementById('footer').textContent = 'Add ?c=CODE to URL';
      return;
    }
    
    document.getElementById('channelName').textContent = 'Loading...';
    supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
    
    await loadScheduleFromBucket();
    subscribeToChannel();
    subscribeToLiveStatus();
  }
  
  async function loadScheduleFromBucket() {
    try {
      const { data: broadcast, error: lookupError } = await supabase
        .from('broadcasts')
        .select('*')
        .eq('code', channelCode.toUpperCase())
        .single();
      
      if (lookupError || !broadcast) throw new Error('Broadcast not found');
      
      isLiveMode = broadcast.auto_update === true;
      updateLiveStatus();
      
      document.getElementById('channelName').textContent = broadcast.title || `Channel ${channelCode}`;
      
      let htmlPath = broadcast.channel_number 
        ? `${broadcast.user_id}/ch${broadcast.channel_number}_${broadcast.file_name}.html`
        : `${broadcast.user_id}/${broadcast.file_name}.html`;
      
      const { data: urlData } = supabase.storage.from('schedule-files').getPublicUrl(htmlPath);
      const publicUrl = urlData.publicUrl + '?t=' + Date.now();
      
      const response = await fetch(publicUrl);
      if (!response.ok) throw new Error('Could not load schedule');
      
      const html = await response.text();
      injectSchedule(html);
      updateFooter('Loaded');
    } catch (err) {
      console.error('Load error:', err);
      document.getElementById('scheduleScroll').innerHTML = 
        `<div style="padding:40px;text-align:center;color:var(--muted);">No schedule found for channel ${channelCode}</div>`;
      updateFooter('No schedule');
    }
  }
  
  function injectSchedule(html) {
    const container = document.getElementById('scheduleScroll');
    container.innerHTML = html;
    
    // Remove buttons and style tags from loaded HTML
    container.querySelectorAll('button').forEach(btn => btn.remove());
    container.querySelectorAll('style').forEach(s => s.remove());
    container.querySelectorAll('.completed-line').forEach(el => el.remove());
    
    // DO NOT strip row backgrounds - we need them for colors!
    
    setupColumns();
    setupRowInteractions();
    initCompletedState();
  }
  
  function initCompletedState() {
    document.querySelectorAll('#scheduleScroll tr[data-completed="true"], #scheduleScroll tr.row-complete').forEach(row => {
      const rowId = row.dataset.id;
      if (rowId && !markedRows.has(rowId)) {
        markedRows.add(rowId);
        const btn = row.querySelector('button.sharpie');
        if (btn) btn.classList.add('active');
        addSharpieLineElement(row);
      }
    });
  }
  
  function setupColumns() {
    const table = document.querySelector('#scheduleScroll table');
    if (!table) return;
    
    const headerRow = table.querySelector('thead tr');
    
    // Add drag header
    if (headerRow && !headerRow.querySelector('th[data-key="drag"]')) {
      const th = document.createElement('th');
      th.setAttribute('data-key', 'drag');
      headerRow.insertBefore(th, headerRow.firstChild);
    }
    
    // Add action header
    if (headerRow && !headerRow.querySelector('th[data-key="actions"]')) {
      const th = document.createElement('th');
      th.setAttribute('data-key', 'actions');
      headerRow.appendChild(th);
    }
    
    // Add colgroup entries
    const colgroup = table.querySelector('colgroup');
    if (colgroup) {
      if (!colgroup.querySelector('col[data-key="drag"]')) {
        const col = document.createElement('col');
        col.setAttribute('data-key', 'drag');
        col.style.width = '60px';
        colgroup.insertBefore(col, colgroup.firstChild);
      }
      if (!colgroup.querySelector('col[data-key="actions"]')) {
        const col = document.createElement('col');
        col.setAttribute('data-key', 'actions');
        col.style.width = '60px';
        colgroup.appendChild(col);
      }
    }
    
    // Add cells to each row
    table.querySelectorAll('tbody tr[data-id]').forEach(row => {
      // Drag cell
      if (!row.querySelector('td[data-key="drag"]')) {
        const td = document.createElement('td');
        td.setAttribute('data-key', 'drag');
        td.style.background = 'transparent';
        td.innerHTML = '<div class="cell-bg"><span class="drag-dots"></span></div>';
        row.insertBefore(td, row.firstChild);
      }
      
      // Action cell
      if (!row.querySelector('td[data-key="actions"]')) {
        const td = document.createElement('td');
        td.setAttribute('data-key', 'actions');
        td.style.background = 'transparent';
        td.innerHTML = `<div class="cell-bg"><button class="sharpie" title="Mark complete">${getSharpieIconSVG()}</button></div>`;
        row.appendChild(td);
      }
    });
    
    // Center header over table (after columns added)
    requestAnimationFrame(() => {
      const header = document.querySelector('#scheduleScroll .header-design-container, #scheduleScroll .header-image');
      if (header && table) {
        const tableWidth = table.offsetWidth;
        const headerWidth = header.offsetWidth;
        // Use the larger of the two so text doesn't overflow
        const targetWidth = Math.max(tableWidth, headerWidth);
        header.style.width = targetWidth + 'px';
        header.style.marginBottom = '12px';
      }
    });
  }
  
  function getSharpieIconSVG() {
    return `<svg viewBox="195 40 100 130"><g transform="rotate(45 245 96)"><path fill="#dd2222" d="m230,66l0,-35q0,-15 12,-21q3,-2 6,0q12,6 12,21l0,35l-30,0z"/><path fill="#e0e0e0" d="m231.5,66l0,75q0,15 6.5,25l14,0q6.5,-10 6.5,-25l0,-75l-27,0z"/><path fill="#bb1111" d="m238,166q-2,10 7,25q9,-15 7,-25l-14,0z"/></g></svg>`;
  }
  
  function setupRowInteractions() {
    const tbody = document.querySelector('#scheduleScroll tbody');
    if (!tbody) return;
    
    // Touch + Mouse drag system (replaces HTML5 Drag and Drop)
    let dragState = null;
    
    tbody.querySelectorAll('tr[data-id]').forEach(row => {
      // Drag handle (grab column) - mouse + touch
      const dragHandle = row.querySelector('td[data-key="drag"]');
      if (dragHandle) {
        dragHandle.addEventListener('mousedown', startDrag);
        dragHandle.addEventListener('touchstart', startDrag, { passive: false });
      }
      
      // Duration cell click
      const durCell = row.querySelector('td[data-key="duration"]');
      if (durCell) {
        durCell.style.cursor = 'pointer';
        durCell.addEventListener('click', () => openDurationEditor(row, durCell));
      }
      
      // Sharpie button
      const sharpieBtn = row.querySelector('button.sharpie');
      if (sharpieBtn) {
        sharpieBtn.addEventListener('click', () => toggleRowSharpie(row));
      }
    });
    
    function startDrag(e) {
      const row = e.currentTarget.closest('tr[data-id]');
      if (!row) return;
      
      // Don't allow dragging sub-events independently
      if (row.dataset.parent) return;
      
      // Prevent text selection
      if (e.type.startsWith('touch')) {
        e.preventDefault();
      }
      
      const clientY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;
      
      dragState = {
        row: row,
        startY: clientY,
        currentY: clientY,
        scrollContainer: document.querySelector('.schedule-scroll')
      };
      
      row.classList.add('dragging');
      draggingRow = row;
      
      document.addEventListener('mousemove', moveDrag);
      document.addEventListener('touchmove', moveDrag, { passive: false });
      document.addEventListener('mouseup', endDrag);
      document.addEventListener('touchend', endDrag);
    }
    
    function moveDrag(e) {
      if (!dragState) return;
      
      if (e.type.startsWith('touch')) {
        e.preventDefault();
      }
      
      const clientY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;
      dragState.currentY = clientY;
      
      // Auto-scroll if dragging near edges
      const scrollContainer = dragState.scrollContainer;
      const rect = scrollContainer.getBoundingClientRect();
      const scrollThreshold = 60;
      const scrollSpeed = 5;
      
      if (clientY - rect.top < scrollThreshold) {
        scrollContainer.scrollTop -= scrollSpeed;
      } else if (rect.bottom - clientY < scrollThreshold) {
        scrollContainer.scrollTop += scrollSpeed;
      }
      
      // Find closest row and reorder
      const candidates = Array.from(tbody.querySelectorAll('tr[data-id]:not(.dragging)'));
      let closest = { offset: -Infinity, element: null };
      
      candidates.forEach(el => {
        const box = el.getBoundingClientRect();
        const offset = clientY - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
          closest = { offset, element: el };
        }
      });
      
      if (closest.element === null) {
        tbody.appendChild(dragState.row);
      } else {
        tbody.insertBefore(dragState.row, closest.element);
      }
    }
    
    function endDrag() {
      if (!dragState) return;
      
      dragState.row.classList.remove('dragging');
      draggingRow = null;
      dragState = null;
      
      document.removeEventListener('mousemove', moveDrag);
      document.removeEventListener('touchmove', moveDrag);
      document.removeEventListener('mouseup', endDrag);
      document.removeEventListener('touchend', endDrag);
      
      broadcastRowOrder();
      updateAllSharpieLines();
    }
  }
  
  function toggleRowSharpie(row) {
    const rowId = row.dataset.id;
    const btn = row.querySelector('button.sharpie');
    const container = document.getElementById('scheduleScroll');
    
    if (markedRows.has(rowId)) {
      markedRows.delete(rowId);
      btn?.classList.remove('active');
      container.querySelector(`.sharpie-line-element[data-row-id="${rowId}"]`)?.remove();
      broadcastEvent('sharpie-toggle', { rowId, marked: false, source: 'ad' });
    } else {
      markedRows.add(rowId);
      btn?.classList.add('active');
      addSharpieLineElement(row);
      broadcastEvent('sharpie-toggle', { rowId, marked: true, source: 'ad' });
    }
  }
  
  function addSharpieLineElement(row) {
    const container = document.getElementById('scheduleScroll');
    const table = container.querySelector('table');
    if (!container || !table) return;
    
    container.querySelector(`.sharpie-line-element[data-row-id="${row.dataset.id}"]`)?.remove();
    
    const line = document.createElement('div');
    line.className = 'sharpie-line-element';
    line.dataset.rowId = row.dataset.id;
    line.style.top = (table.offsetTop + row.offsetTop + row.offsetHeight / 2 - 2) + 'px';
    line.style.left = (table.offsetLeft + 36) + 'px';
    line.style.width = (table.offsetWidth - 72) + 'px';
    container.appendChild(line);
  }
  
  function updateAllSharpieLines() {
    const container = document.getElementById('scheduleScroll');
    const table = container?.querySelector('table');
    if (!table) return;
    
    markedRows.forEach(rowId => {
      const row = document.querySelector(`tr[data-id="${rowId}"]`);
      const line = container.querySelector(`.sharpie-line-element[data-row-id="${rowId}"]`);
      if (row && line) {
        line.style.top = (table.offsetTop + row.offsetTop + row.offsetHeight / 2 - 2) + 'px';
        line.style.left = (table.offsetLeft + 36) + 'px';
        line.style.width = (table.offsetWidth - 72) + 'px';
      }
    });
  }
  
  function openDurationEditor(row, cell) {
    const popup = document.getElementById('durationPopup');
    const input = document.getElementById('durationInput');
    const rect = cell.getBoundingClientRect();
    
    popup.style.left = rect.left + 'px';
    popup.style.top = (rect.bottom + 4) + 'px';
    popup.classList.add('show');
    input.value = cell.textContent.trim();
    input.focus();
    input.select();
    
    const close = () => {
      popup.classList.remove('show');
      document.removeEventListener('click', outsideClick);
      input.removeEventListener('keydown', keyHandler);
    };
    
    const save = () => {
      const newValue = input.value.trim();
      if (newValue !== cell.textContent.trim()) {
        cell.textContent = newValue;
        broadcastEvent('duration-change', { rowId: row.dataset.id, duration: newValue, source: 'ad' });
      }
      close();
    };
    
    const outsideClick = (e) => { if (!popup.contains(e.target) && e.target !== cell) save(); };
    const keyHandler = (e) => {
      if (e.key === 'Enter') { e.preventDefault(); save(); }
      else if (e.key === 'Escape') close();
    };
    
    setTimeout(() => {
      document.addEventListener('click', outsideClick);
      input.addEventListener('keydown', keyHandler);
    }, 10);
  }
  
  function subscribeToChannel() {
    channel = supabase.channel(`ad-sync-${channelCode.toUpperCase()}`, {
      config: { broadcast: { self: false } }
    });
    
    channel
      .on('broadcast', { event: 'row-reorder' }, ({ payload }) => {
        if (!payload?.order) return;
        const tbody = document.querySelector('#scheduleScroll tbody');
        if (!tbody) return;
        payload.order.forEach(id => {
          const row = tbody.querySelector(`tr[data-id="${id}"]`);
          if (row) {
            tbody.appendChild(row);
            // Move sub-events with their parent
            const subEvents = tbody.querySelectorAll(`tr[data-parent="${id}"]`);
            subEvents.forEach(sub => tbody.appendChild(sub));
          }
        });
        updateAllSharpieLines();
      })
      .on('broadcast', { event: 'duration-change' }, ({ payload }) => {
        if (!payload?.rowId) return;
        const row = document.querySelector(`tr[data-id="${payload.rowId}"]`);
        const cell = row?.querySelector('td[data-key="duration"]');
        if (cell) cell.textContent = payload.duration;
      })
      .on('broadcast', { event: 'sharpie-toggle' }, ({ payload }) => {
        if (!payload?.rowId) return;
        const row = document.querySelector(`tr[data-id="${payload.rowId}"]`);
        if (!row) return;
        const btn = row.querySelector('button.sharpie');
        if (payload.marked) {
          markedRows.add(payload.rowId);
          btn?.classList.add('active');
          addSharpieLineElement(row);
        } else {
          markedRows.delete(payload.rowId);
          btn?.classList.remove('active');
          document.getElementById('scheduleScroll').querySelector(`.sharpie-line-element[data-row-id="${payload.rowId}"]`)?.remove();
        }
      })
      .on('broadcast', { event: 'sharpie-visibility' }, ({ payload }) => {
        linesHidden = payload.hidden;
        document.body.classList.toggle('sharpie-lines-hidden', linesHidden);
      })
      .on('broadcast', { event: 'cell-format' }, ({ payload }) => {
        if (!payload?.rowId || !payload?.columnKey || !payload?.formatting) return;
        const row = document.querySelector(`tr[data-id="${payload.rowId}"]`);
        const cell = row?.querySelector(`td[data-key="${payload.columnKey}"]`);
        if (cell) {
          // Apply formatting via dataset
          Object.entries(payload.formatting).forEach(([key, value]) => {
            if (value !== undefined && value !== null && value !== '') {
              cell.dataset[key] = value;
              // Also apply as inline styles for immediate visual feedback
              applyFormatting(cell, payload.formatting);
            }
          });
        }
      })
      .on('broadcast', { event: 'row-format' }, ({ payload }) => {
        if (!payload?.rowId || !payload?.formatting) return;
        const row = document.querySelector(`tr[data-id="${payload.rowId}"]`);
        if (!row) return;
        const cells = row.querySelectorAll('td[data-key]:not([data-key="drag"]):not([data-key="actions"])');
        cells.forEach(cell => {
          const key = cell.dataset.key;
          const cellFormat = payload.formatting[key];
          if (cellFormat) {
            Object.entries(cellFormat).forEach(([fmtKey, fmtValue]) => {
              if (fmtValue !== undefined && fmtValue !== null && fmtValue !== '') {
                cell.dataset[fmtKey] = fmtValue;
              }
            });
            applyFormatting(cell, cellFormat);
          }
        });
      })
      .on('broadcast', { event: 'full-sync' }, ({ payload }) => {
        if (payload?.html) injectSchedule(payload.html);
        if (payload?.order) {
          const tbody = document.querySelector('#scheduleScroll tbody');
          payload.order.forEach(id => {
            const row = tbody?.querySelector(`tr[data-id="${id}"]`);
            if (row) {
              tbody.appendChild(row);
              // Move sub-events with their parent
              const subEvents = tbody.querySelectorAll(`tr[data-parent="${id}"]`);
              subEvents.forEach(sub => tbody.appendChild(sub));
            }
          });
        }
        updateAllSharpieLines();
      })
      .on('broadcast', { event: 'row-times' }, ({ payload }) => {
        // Update START and END times from producer after reorder/duration change
        if (!payload?.times) return;
        Object.entries(payload.times).forEach(([rowId, times]) => {
          const row = document.querySelector(`tr[data-id="${rowId}"]`);
          if (!row) return;
          const startCell = row.querySelector('td[data-key="start"]');
          const endCell = row.querySelector('td[data-key="end"]');
          if (startCell && times.start) startCell.textContent = times.start;
          if (endCell && times.end) endCell.textContent = times.end;
        });
      })
      .on('broadcast', { event: 'sync-status' }, ({ payload }) => {
        // Producer is telling us sync status (live/offline)
        if (payload?.live !== undefined) {
          isLiveMode = payload.live;
          updateLiveStatus();
        }
      })
      .on('broadcast', { event: 'heartbeat' }, () => {
        // Heartbeat received from producer - we're still connected
        lastHeartbeat = Date.now();
      })
      .subscribe((status) => {
        console.log('[AD] Channel subscription status:', status);
        if (status === 'SUBSCRIBED') {
          reconnectAttempts = 0;
          clearTimeout(reconnectTimer);
          updateFooter('Connected');
          broadcastEvent('request-sync', {});
          startHeartbeat();
        } else if (status === 'CLOSED' || status === 'CHANNEL_ERROR') {
          updateFooter('Disconnected');
          stopHeartbeat();
          scheduleReconnect();
        } else {
          updateFooter(status);
        }
      });
  }

  function startHeartbeat() {
    stopHeartbeat();
    lastHeartbeat = Date.now();

    heartbeatTimer = setInterval(() => {
      const timeSinceLastHeartbeat = Date.now() - lastHeartbeat;

      // Send our own heartbeat ping
      broadcastEvent('heartbeat-ping', { timestamp: Date.now() });

      // Check if we've lost connection (no heartbeat from producer)
      if (timeSinceLastHeartbeat > HEARTBEAT_TIMEOUT) {
        console.log('[AD] Heartbeat timeout - reconnecting');
        updateFooter('Connection lost - reconnecting...');
        stopHeartbeat();
        scheduleReconnect();
      }
    }, HEARTBEAT_INTERVAL);
  }

  function stopHeartbeat() {
    if (heartbeatTimer) {
      clearInterval(heartbeatTimer);
      heartbeatTimer = null;
    }
  }

  function scheduleReconnect() {
    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
      updateFooter('Connection failed - please refresh');
      return;
    }

    // Exponential backoff: 1s, 2s, 4s, 8s, 16s, max 30s
    const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
    reconnectAttempts++;

    console.log(`[AD] Reconnect attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`);
    updateFooter(`Reconnecting (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);

    clearTimeout(reconnectTimer);
    reconnectTimer = setTimeout(() => {
      reconnect();
    }, delay);
  }

  async function reconnect() {
    console.log('[AD] Attempting reconnect...');

    // Cleanup old channel
    if (channel) {
      try {
        await channel.unsubscribe();
      } catch (e) {
        console.log('[AD] Error unsubscribing:', e);
      }
      channel = null;
    }

    // Resubscribe
    subscribeToChannel();
  }
  
  function broadcastEvent(event, payload) {
    if (channel) channel.send({ type: 'broadcast', event, payload: { ...payload, source: 'ad' } });
  }
  
  function applyFormatting(cell, formatting) {
    if (!cell) return;
    
    // Text color
    if (formatting.cellFg !== undefined) {
      if (formatting.cellFg) {
        cell.style.color = formatting.cellFg;
      } else {
        cell.style.removeProperty('color');
      }
    }
    if (formatting.fgColor !== undefined) {
      if (formatting.fgColor) {
        cell.style.color = formatting.fgColor;
      } else {
        cell.style.removeProperty('color');
      }
    }
    
    // Background color
    if (formatting.cellBg !== undefined) {
      if (formatting.cellBg) {
        cell.style.backgroundColor = formatting.cellBg;
      } else {
        cell.style.removeProperty('background-color');
      }
    }
    if (formatting.bgColor !== undefined) {
      if (formatting.bgColor) {
        cell.style.backgroundColor = formatting.bgColor;
      } else {
        cell.style.removeProperty('background-color');
      }
    }
    
    // Alignment
    if (formatting.align !== undefined) {
      if (formatting.align) {
        cell.style.textAlign = formatting.align;
      } else {
        cell.style.removeProperty('text-align');
      }
    }
    
    // Vertical alignment
    if (formatting.valign !== undefined) {
      if (formatting.valign) {
        cell.style.verticalAlign = formatting.valign;
      } else {
        cell.style.removeProperty('vertical-align');
      }
    }
    
    // Font family
    if (formatting.fontFamily !== undefined) {
      if (formatting.fontFamily) {
        cell.style.fontFamily = formatting.fontFamily;
      } else {
        cell.style.removeProperty('font-family');
      }
    }
    
    // Font size
    if (formatting.fontSize !== undefined) {
      if (formatting.fontSize) {
        cell.style.fontSize = formatting.fontSize;
      } else {
        cell.style.removeProperty('font-size');
      }
    }
    
    // Bold
    if (formatting.bold !== undefined) {
      cell.style.fontWeight = formatting.bold ? 'bold' : 'normal';
    }
    
    // Italic
    if (formatting.italic !== undefined) {
      cell.style.fontStyle = formatting.italic ? 'italic' : 'normal';
    }
    
    // Underline
    if (formatting.underline !== undefined) {
      cell.style.textDecoration = formatting.underline ? 'underline' : 'none';
    }
  }
  
  
  function broadcastRowOrder() {
    const tbody = document.querySelector('#scheduleScroll tbody');
    if (!tbody) return;
    // Only include parent rows, not sub-events
    const order = Array.from(tbody.querySelectorAll('tr[data-id]:not([data-parent])')).map(r => r.dataset.id);
    broadcastEvent('row-reorder', { order, source: 'ad' });
  }
  
  function updateFooter(status) {
    document.getElementById('footer').textContent = `${status} â€¢ ${new Date().toLocaleTimeString()}`;
  }
  
  function updateLiveStatus() {
    const badge = document.getElementById('liveBadge');
    badge.classList.remove('live', 'manual');
    badge.classList.add(isLiveMode ? 'live' : 'manual');
  }
  
  // Subscribe to realtime changes on broadcast record for instant LIVE badge updates
  let broadcastSubscription = null;
  function subscribeToLiveStatus() {
    if (!channelCode || !supabase) return;
    
    broadcastSubscription = supabase
      .channel('broadcast-status-' + channelCode.toUpperCase())
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'broadcasts',
        filter: `code=eq.${channelCode.toUpperCase()}`
      }, (payload) => {
        console.log('[AD Sync] Broadcast record updated:', payload);
        if (payload.new && payload.new.auto_update !== undefined) {
          const wasLive = isLiveMode;
          isLiveMode = payload.new.auto_update === true;
          if (wasLive !== isLiveMode) {
            console.log('[AD Sync] LIVE status changed:', isLiveMode ? 'LIVE' : 'MANUAL');
            updateLiveStatus();
          }
        }
      })
      .subscribe((status) => {
        console.log('[AD Sync] Broadcast status subscription:', status);
      });
  }

  // Cleanup on page unload
  window.addEventListener('beforeunload', () => {
    stopHeartbeat();
    clearTimeout(reconnectTimer);
    if (channel) {
      try {
        channel.unsubscribe();
      } catch (e) {}
    }
    if (broadcastSubscription) {
      try {
        broadcastSubscription.unsubscribe();
      } catch (e) {}
    }
  });

  // Handle visibility change - reconnect when page becomes visible again
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible' && channelCode) {
      // Check if we need to reconnect
      const timeSinceLastHeartbeat = Date.now() - lastHeartbeat;
      if (timeSinceLastHeartbeat > HEARTBEAT_TIMEOUT) {
        console.log('[AD] Page visible after timeout - reconnecting');
        scheduleReconnect();
      }
    }
  });

  document.addEventListener('DOMContentLoaded', init);
})();
</script>
</body>
</html>
