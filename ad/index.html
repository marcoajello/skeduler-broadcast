<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#0d1117">
  <title>SKEDULER AD</title>
  <style>
    * { box-sizing: border-box; }
    
    :root {
      --bg: #0d1117;
      --panel: #222a35;
      --border: #30363d;
      --text: #e6edf3;
      --muted: #7d8590;
      --accent: #58a6ff;
      --live-red: #f85149;
      --live-green: #3fb950;
    }
    
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Avenir', sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
    }
    
    /* ===== HEADER ===== */
    .header {
      position: sticky;
      top: 0;
      z-index: 100;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      padding: 12px 16px;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      min-height: 48px;
    }
    
    .header-left {
      display: flex;
      align-items: center;
      gap: 8px;
      justify-self: start;
    }
    
    .header-logo {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 2px;
      color: var(--text);
    }
    
    .header-logo svg {
      width: 20px;
      height: 20px;
    }
    
    .header-center {
      justify-self: center;
      text-align: center;
      flex: 1;
    }
    
    .channel-name {
      font-size: 16px;
      font-weight: 700;
      color: var(--text);
      letter-spacing: 1px;
    }
    
    .header-right {
      display: flex;
      align-items: center;
      gap: 12px;
      justify-self: end;
    }
    
    /* ===== LIVE INDICATOR ===== */
    .live-badge {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    
    .live-badge.live {
      background: rgba(248, 81, 73, 0.15);
      color: var(--live-red);
      border: 1px solid rgba(248, 81, 73, 0.3);
    }
    
    .live-badge.live .live-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--live-red);
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    .live-badge.synced {
      background: rgba(63, 185, 80, 0.15);
      color: var(--live-green);
      border: 1px solid rgba(63, 185, 80, 0.3);
    }
    
    .live-badge.synced .live-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--live-green);
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    .live-badge.connecting {
      background: rgba(88, 166, 255, 0.15);
      color: var(--accent);
      border: 1px solid rgba(88, 166, 255, 0.3);
    }
    
    .live-badge.connecting .live-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent);
      animation: pulse 0.5s ease-in-out infinite;
    }
    
    .live-badge.offline {
      background: rgba(125, 133, 144, 0.15);
      color: var(--muted);
      border: 1px solid rgba(125, 133, 144, 0.3);
    }
    
    .live-badge.offline .live-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--muted);
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(0.9); }
    }
    
    /* ===== SHARPIE TOGGLE (Purple for AD) ===== */
    .header-progress-btn {
      width: 28px; height: 28px; padding: 4px; border-radius: 4px; border: none;
      background: #9333ea; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
    }
    .header-progress-btn:hover { filter: brightness(1.1); }
    .header-progress-btn.lines-hidden { background: var(--border); }
    .header-progress-btn:not(.lines-hidden) { background: #9333ea; }
    .header-progress-btn svg path[fill="#dd2222"],
    .header-progress-btn svg path[fill="#bb1111"] { fill: #7c3aed; }
    
    /* ===== CONTENT ===== */
    .content {
      padding: 16px;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      background: #000;
    }
    
    .loading, .error {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 60vh;
      text-align: center;
      padding: 24px;
    }
    
    .loading h2, .error h2 {
      font-size: 18px;
      margin: 0 0 8px;
    }
    
    .loading p, .error p {
      color: var(--muted);
      margin: 0;
    }
    
    .error h2 { color: var(--live-red); }
    
    .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 16px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* ===== CONTENT CENTERING ===== */
    .content {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    /* ===== SCHEDULE CONTAINER ===== */
    #schedule-container {
      background: #000;
      border-radius: 8px;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      display: flex;
      flex-direction: column;
      align-items: center;
      width: auto;
      max-width: 100%;
    }
    
    /* Center the schedule header over table */
    #schedule-container .schedule-header,
    #schedule-container .header-image,
    #schedule-container > div:first-child:not(table) {
      text-align: center;
      width: 100%;
    }
    
    #schedule-container table {
      margin: 0 auto;
      border-collapse: collapse;
      background: #000;
    }
    
    #schedule-container .schedule-scroll {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      background: #000;
    }
    
    /* ===== COMPLETED ROW LINES ===== */
    body.show-progress .completed-line {
      display: block;
    }
    
    body:not(.show-progress) .completed-line {
      display: none;
    }
    
    /* ===== TAG PILLS ===== */
    #schedule-container .tags-pills {
      display: flex;
      flex-wrap: wrap;
      flex-direction: row;
      gap: 4px;
      padding: 4px;
      align-items: flex-start;
      align-content: flex-start;
    }
    
    #schedule-container .tag-pill {
      display: inline-flex;
      width: auto;
      max-width: none;
      flex: 0 0 auto;
      align-items: center;
      gap: 4px;
      padding: 2px 8px 2px 3px;
      border-radius: 999px;
      font-size: 10px;
      font-weight: 600;
      white-space: nowrap;
    }
    
    #schedule-container .tag-pill img {
      width: 20px;
      height: 20px;
      min-width: 20px;
      min-height: 20px;
      max-width: 20px;
      max-height: 20px;
      border-radius: 50%;
      object-fit: cover;
      flex-shrink: 0;
    }
    
    /* ===== DRAGGABLE ROWS ===== */
    #schedule-container tr[data-id].dragging {
      opacity: 0.5;
    }
    
    #schedule-container tr[data-id].drag-over {
      border-top: 3px solid var(--accent);
    }
    
    /* ===== DRAG COLUMN ===== */
    .ad-drag-col {
      width: 36px;
      min-width: 36px;
      max-width: 36px;
    }
    
    .ad-drag-th, .ad-drag-td {
      width: 36px;
      min-width: 36px;
      max-width: 36px;
      padding: 0;
      text-align: center;
      vertical-align: middle;
      background: #4b5563;
      border: 2px solid #ffffff;
      border-right: 1px solid #ffffff;
    }
    
    /* Remove top border doubling on body cells */
    .ad-drag-td {
      border-top: none;
    }
    
    .ad-drag-handle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      min-height: 30px;
      cursor: grab;
      color: #999;
      font-size: 14px;
      user-select: none;
    }
    
    .ad-drag-handle:hover {
      color: #fff;
      background: rgba(255,255,255,0.1);
    }
    
    .ad-drag-handle:active {
      cursor: grabbing;
    }
    
    /* ===== ACTIONS COLUMN ===== */
    .ad-actions-col {
      width: 50px;
      min-width: 50px;
      max-width: 50px;
    }
    
    .ad-actions-th, .ad-actions-td {
      width: 50px;
      min-width: 50px;
      max-width: 50px;
      padding: 4px;
      text-align: center;
      vertical-align: middle;
      background: #4b5563;
      border: 2px solid #ffffff;
      border-left: 1px solid #ffffff;
    }
    
    /* Remove top border doubling on body cells */
    .ad-actions-td {
      border-top: none;
    }
    
    /* Rounded outer corners */
    #schedule-container thead tr:first-child .ad-drag-th {
      border-top-left-radius: 8px;
    }
    
    #schedule-container thead tr:first-child .ad-actions-th {
      border-top-right-radius: 8px;
    }
    
    #schedule-container tbody tr:last-child .ad-drag-td {
      border-bottom-left-radius: 8px;
      border-bottom: 2px solid #ffffff;
    }
    
    #schedule-container tbody tr:last-child .ad-actions-td {
      border-bottom-right-radius: 8px;
      border-bottom: 2px solid #ffffff;
    }
    
    .ad-mark-btn {
      width: 32px;
      height: 32px;
      background: transparent;
      border: 1px solid #555;
      border-radius: 6px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      transition: all 0.15s;
    }
    
    .ad-mark-btn:hover {
      background: rgba(147, 51, 234, 0.2);
      border-color: #9333ea;
    }
    
    .ad-mark-btn.marked {
      background: #9333ea;
      border-color: #9333ea;
    }
    
    .ad-mark-btn svg {
      width: 18px;
      height: 18px;
    }
    
    /* Completed line styling (purple for AD) */
    .ad-completed-line {
      position: absolute;
      left: 0;
      top: 50%;
      width: 5000px;
      height: 4px;
      background: #9333ea;
      pointer-events: none;
      transform: translateY(-50%);
      z-index: 100;
    }
    
    body:not(.show-progress) .ad-completed-line {
      display: none;
    }
    
    /* Row needs relative positioning for the line */
    #schedule-container tr[data-id] {
      position: relative;
    }
    
    #schedule-container tr[data-id] td:first-child {
      position: relative;
    }
    
    /* Subchild rows - don't allow dragging */
    #schedule-container tr.subchild .ad-drag-handle {
      opacity: 0.3;
      cursor: default;
    }
    
    /* ===== DURATION EDIT ===== */
    #schedule-container td[data-key="duration"] {
      cursor: pointer;
    }
    
    #schedule-container td[data-key="duration"]:hover {
      background: rgba(88, 166, 255, 0.1);
    }
    
    .duration-edit-input {
      width: 50px;
      padding: 2px 4px;
      font-size: inherit;
      font-family: inherit;
      text-align: center;
      border: 1px solid var(--accent);
      border-radius: 4px;
      background: var(--panel);
      color: var(--text);
    }
    
    /* ===== FOOTER ===== */
    .updated-at {
      text-align: center;
      padding: 12px;
      font-size: 11px;
      color: var(--muted);
    }
    
    /* ===== NOTIFICATION ===== */
    .notification {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 12px;
      color: var(--text);
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }
    
    .notification.show {
      opacity: 1;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body class="show-progress">
  <div class="header">
    <div class="header-left">
      <div class="header-logo">
        <svg viewBox="195 40 100 130">
          <defs>
            <linearGradient id="hCapG" x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" stop-color="#cc2222"/>
              <stop offset="40%" stop-color="#ee3333"/>
              <stop offset="100%" stop-color="#aa1111"/>
            </linearGradient>
            <linearGradient id="hTipG" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" stop-color="#dd2222"/>
              <stop offset="100%" stop-color="#991111"/>
            </linearGradient>
            <linearGradient id="hBodyG" x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" stop-color="#d0d0d0"/>
              <stop offset="30%" stop-color="#eeeeee"/>
              <stop offset="70%" stop-color="#e0e0e0"/>
              <stop offset="100%" stop-color="#c8c8c8"/>
            </linearGradient>
            <linearGradient id="hClipG" x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" stop-color="#aa1111"/>
              <stop offset="50%" stop-color="#dd3333"/>
              <stop offset="100%" stop-color="#991111"/>
            </linearGradient>
          </defs>
          <g transform="rotate(45 245 96)">
            <path fill="url(#hCapG)" d="m230,66l0,-35q0,-15 12,-21q3,-2 6,0q12,6 12,21l0,35l-30,0z"/>
            <path fill="rgba(255,255,255,0.25)" d="m234,61l0,-27q0,-14 8,-20l0,47l-8,0z"/>
            <path fill="url(#hClipG)" d="m258,21l4,0q6,0 6,6l0,47q0,2 -2,2l-6,0q-2,0 -2,-2l0,-53z"/>
            <ellipse fill="#881111" cx="263" cy="76" rx="5" ry="2.5"/>
            <path fill="url(#hBodyG)" d="m231.5,66l0,75q0,15 6.5,25l14,0q6.5,-10 6.5,-25l0,-75l-27,0z"/>
            <rect fill="rgba(255,255,255,0.4)" x="234" y="69" width="5" height="68" rx="2"/>
            <path fill="url(#hTipG)" d="m238,166q-2,10 7,25q9,-15 7,-25l-14,0z"/>
            <path fill="rgba(255,255,255,0.15)" d="m240,168q-1,8 5,20l0,-19l-5,-1z"/>
          </g>
        </svg>
        <span>SKEDULER AD</span>
      </div>
    </div>
    
    <div class="header-center">
      <div class="channel-name" id="channelName">Connecting...</div>
    </div>
    
    <div class="header-right">
      <div class="live-badge connecting" id="liveBadge">
        <span id="liveText">CONNECTING</span>
        <span class="live-dot"></span>
      </div>
      <button class="header-progress-btn" id="sharpieToggle" title="Toggle Progress Lines">
        <svg width="18" height="18" viewBox="195 40 100 130"><g transform="rotate(45 245 96)"><path fill="#dd2222" d="m230,66l0,-35q0,-15 12,-21q3,-2 6,0q12,6 12,21l0,35l-30,0z"/><path fill="#e0e0e0" d="m231.5,66l0,75q0,15 6.5,25l14,0q6.5,-10 6.5,-25l0,-75l-27,0z"/><path fill="#bb1111" d="m238,166q-2,10 7,25q9,-15 7,-25l-14,0z"/></g></svg>
      </button>
    </div>
  </div>
  
  <div class="content">
    <div id="loading" class="loading">
      <div class="spinner"></div>
      <h2>Connecting to Channel...</h2>
      <p>Please wait</p>
    </div>
    
    <div id="error" class="error" style="display:none;">
      <h2>Connection Failed</h2>
      <p>Could not connect to the AD channel.</p>
    </div>
    
    <div id="schedule-container" style="display:none;"></div>
    <div id="updated-at" class="updated-at"></div>
  </div>
  
  <div class="notification" id="notification"></div>

  <script>
  (function() {
    'use strict';
    
    const SUPABASE_URL = 'https://qcnepxcqilqrhayzhlfa.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFjbmVweGNxaWxxcmhheXpobGZhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI0NTgwMjYsImV4cCI6MjA3ODAzNDAyNn0.Gz7wvMgtu-UtCqw-5MF9s-T-pk-eo2TSw7zOtedWozk';
    
    let supabase = null;
    let channelCode = null;
    let channel = null;
    let progressVisible = true;
    let isLive = false;
    let markedRows = new Set();
    
    // Drag state
    let draggedRow = null;
    
    async function init() {
      const params = new URLSearchParams(window.location.search);
      channelCode = params.get('c') || params.get('code') || params.get('channel');
      
      if (!channelCode) {
        showError('No channel code provided. Add ?c=YOURCODE to the URL.');
        return;
      }
      
      channelCode = channelCode.toUpperCase();
      document.getElementById('channelName').textContent = 'Channel: ' + channelCode;
      document.title = 'AD - ' + channelCode;
      
      // Initialize Supabase
      supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
      
      // Fetch channel title from Supabase
      async function fetchChannelTitle(code) {
        try {
          const { data, error } = await supabase
            .from('broadcasts')
            .select('title')
            .ilike('code', code)
            .single();
          
          if (data?.title) {
            document.getElementById('channelName').textContent = data.title;
            document.title = 'AD - ' + data.title;
          }
        } catch (e) {
          console.log('[AD] Could not fetch channel title:', e);
        }
      }
      
      fetchChannelTitle(channelCode);
      
      // Setup progress toggle
      document.getElementById('sharpieToggle').addEventListener('click', toggleProgress);
      
      // Load initial HTML from storage
      await loadInitialHTML();
      
      // Connect to realtime channel
      await connectToChannel();
    }
    
    async function loadInitialHTML() {
      try {
        // Look up broadcast by code to get the HTML path
        const { data: broadcast, error } = await supabase
          .from('broadcasts')
          .select('*')
          .eq('code', channelCode)
          .single();
        
        if (error || !broadcast) {
          console.log('[AD] No broadcast found, waiting for sync');
          return;
        }
        
        // Fetch HTML
        let htmlPath;
        if (broadcast.channel_number) {
          htmlPath = broadcast.user_id + '/ch' + broadcast.channel_number + '_' + broadcast.file_name + '.html';
        } else {
          htmlPath = broadcast.user_id + '/' + broadcast.file_name + '.html';
        }
        
        const { data: urlData } = supabase.storage
          .from('schedule-files')
          .getPublicUrl(htmlPath);
        
        const response = await fetch(urlData.publicUrl + '?t=' + Date.now());
        if (response.ok) {
          const html = await response.text();
          displaySchedule(html);
        }
      } catch (err) {
        console.error('[AD] Error loading initial HTML:', err);
      }
    }
    
    async function connectToChannel() {
      const roomName = 'ad-sync-' + channelCode;
      console.log('[AD] Connecting to room:', roomName);
      
      channel = supabase.channel(roomName, {
        config: {
          broadcast: { self: false }
        }
      });
      
      channel
        .on('broadcast', { event: 'full-sync' }, handleFullSync)
        .on('broadcast', { event: 'row-reorder' }, handleRowReorder)
        .on('broadcast', { event: 'duration-change' }, handleDurationChange)
        .on('broadcast', { event: 'sharpie-toggle' }, handleSharpieToggle)
        .on('broadcast', { event: 'sharpie-visibility' }, handleSharpieVisibility)
        .on('broadcast', { event: 'sync-status' }, handleSyncStatus)
        .on('presence', { event: 'sync' }, handlePresence)
        .subscribe((status) => {
          console.log('[AD] Subscription status:', status);
          
          if (status === 'SUBSCRIBED') {
            // Track presence
            channel.track({
              user: 'AD-' + Math.random().toString(36).substr(2, 4),
              role: 'ad'
            });
            
            // Request current state from producer
            channel.send({
              type: 'broadcast',
              event: 'request-sync',
              payload: {}
            });
            
            updateStatus('connecting');
            showNotification('Connected, waiting for producer...');
          }
        });
    }
    
    function displaySchedule(html) {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('error').style.display = 'none';
      document.getElementById('schedule-container').style.display = 'block';
      document.getElementById('schedule-container').innerHTML = html;
      document.getElementById('updated-at').textContent = 'Updated: ' + new Date().toLocaleTimeString();
      
      // Setup interactive features
      setupRowInteractions();
    }
    
    function setupRowInteractions() {
      const container = document.getElementById('schedule-container');
      const table = container.querySelector('table');
      if (!table) return;
      
      // Add drag column to colgroup
      const colgroup = table.querySelector('colgroup');
      if (colgroup) {
        const dragCol = document.createElement('col');
        dragCol.className = 'ad-drag-col';
        dragCol.dataset.key = 'drag';
        colgroup.insertBefore(dragCol, colgroup.firstChild);
        
        const actionsCol = document.createElement('col');
        actionsCol.className = 'ad-actions-col';
        actionsCol.dataset.key = 'actions';
        colgroup.appendChild(actionsCol);
      }
      
      // Add drag header
      const thead = table.querySelector('thead tr');
      if (thead) {
        const dragTh = document.createElement('th');
        dragTh.className = 'ad-drag-th';
        dragTh.dataset.key = 'drag';
        dragTh.innerHTML = '';
        thead.insertBefore(dragTh, thead.firstChild);
        
        const actionsTh = document.createElement('th');
        actionsTh.className = 'ad-actions-th';
        actionsTh.dataset.key = 'actions';
        actionsTh.innerHTML = '';
        thead.appendChild(actionsTh);
      }
      
      // Add drag and actions cells to each row (including subchildren)
      const rows = table.querySelectorAll('tbody tr');
      
      rows.forEach(row => {
        // Get row ID - check both data-id and id attributes
        const rowId = row.dataset.id || row.id;
        
        // Skip rows without IDs (like separator rows)
        if (!rowId) return;
        
        // Check if this is a subchild row
        const isSubchild = row.classList.contains('subchild');
        
        // Add drag cell at start
        const dragTd = document.createElement('td');
        dragTd.className = 'ad-drag-td';
        dragTd.dataset.key = 'drag';
        
        const dragHandle = document.createElement('div');
        dragHandle.className = 'ad-drag-handle';
        dragHandle.innerHTML = '⋮⋮';
        
        // Only make non-subchild rows draggable
        if (!isSubchild) {
          dragHandle.draggable = true;
          dragHandle.addEventListener('dragstart', (e) => handleDragStart(e, row));
          dragHandle.addEventListener('dragend', handleDragEnd);
        }
        dragTd.appendChild(dragHandle);
        
        row.insertBefore(dragTd, row.firstChild);
        
        // Add actions cell at end
        const actionsTd = document.createElement('td');
        actionsTd.className = 'ad-actions-td';
        actionsTd.dataset.key = 'actions';
        
        const markBtn = document.createElement('button');
        markBtn.className = 'ad-mark-btn' + (markedRows.has(rowId) ? ' marked' : '');
        markBtn.innerHTML = getSharpieIcon(markedRows.has(rowId));
        markBtn.addEventListener('click', () => toggleRowComplete(rowId, markBtn));
        actionsTd.appendChild(markBtn);
        
        row.appendChild(actionsTd);
        
        // Row drag events (for dropping) - only on non-subchild rows
        if (!isSubchild) {
          row.addEventListener('dragover', handleDragOver);
          row.addEventListener('dragleave', handleDragLeave);
          row.addEventListener('drop', handleDrop);
        }
        
        // If row is already marked, show line
        if (markedRows.has(rowId)) {
          showCompletedLine(rowId);
        }
        
        // Click duration cell to edit
        const durationCell = row.querySelector('td[data-key="duration"]');
        if (durationCell) {
          durationCell.style.cursor = 'pointer';
          durationCell.addEventListener('click', (e) => {
            e.stopPropagation();
            editDuration(rowId, durationCell);
          });
        }
      });
    }
    
    function getSharpieIcon(isMarked) {
      const color = isMarked ? '#fff' : '#9333ea';
      return '<svg viewBox="195 40 100 130"><g transform="rotate(45 245 96)"><path fill="' + color + '" d="m230,66l0,-35q0,-15 12,-21q3,-2 6,0q12,6 12,21l0,35l-30,0z"/><path fill="' + (isMarked ? '#fff' : '#e0e0e0') + '" d="m231.5,66l0,75q0,15 6.5,25l14,0q6.5,-10 6.5,-25l0,-75l-27,0z"/><path fill="' + color + '" d="m238,166q-2,10 7,25q9,-15 7,-25l-14,0z"/></g></svg>';
    }
    
    // ===== DRAG AND DROP =====
    function handleDragStart(e, row) {
      // Don't allow dragging subchild rows
      if (row.classList.contains('subchild')) {
        e.preventDefault();
        return;
      }
      
      draggedRow = row;
      draggedRow.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setDragImage(row, 50, 20);
    }
    
    function handleDragEnd(e) {
      if (draggedRow) {
        draggedRow.classList.remove('dragging');
        draggedRow = null;
      }
      document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
    }
    
    function handleDragOver(e) {
      e.preventDefault();
      const row = e.target.closest('tr[data-id]:not(.subchild)');
      if (row && row !== draggedRow) {
        row.classList.add('drag-over');
      }
    }
    
    function handleDragLeave(e) {
      const row = e.target.closest('tr[data-id]');
      if (row) {
        row.classList.remove('drag-over');
      }
    }
    
    function handleDrop(e) {
      e.preventDefault();
      const targetRow = e.target.closest('tr[data-id]:not(.subchild)');
      if (!targetRow || !draggedRow || targetRow === draggedRow) return;
      
      // Don't drop onto subchild rows
      if (targetRow.classList.contains('subchild')) return;
      
      targetRow.classList.remove('drag-over');
      
      // Get the dragged row and its subchildren (if SUB row)
      const draggedId = draggedRow.dataset.id || draggedRow.id;
      const tbody = targetRow.parentElement;
      
      // Collect the dragged row and any subchildren
      const rowsToMove = [draggedRow];
      if (draggedRow.dataset.type === 'SUB') {
        const subchildren = tbody.querySelectorAll('tr.subchild[data-parent="' + draggedId + '"]');
        subchildren.forEach(child => rowsToMove.push(child));
      }
      
      // Determine target position
      const rows = Array.from(tbody.querySelectorAll('tr[data-id]:not(.subchild)'));
      const draggedIndex = rows.indexOf(draggedRow);
      const targetIndex = rows.indexOf(targetRow);
      
      // Move all rows
      if (draggedIndex < targetIndex) {
        // Moving down - insert after target (and its subchildren)
        let insertAfter = targetRow;
        if (targetRow.dataset.type === 'SUB') {
          const targetSubchildren = tbody.querySelectorAll('tr.subchild[data-parent="' + (targetRow.dataset.id || targetRow.id) + '"]');
          if (targetSubchildren.length > 0) {
            insertAfter = targetSubchildren[targetSubchildren.length - 1];
          }
        }
        rowsToMove.forEach(row => {
          insertAfter.after(row);
          insertAfter = row;
        });
      } else {
        // Moving up - insert before target
        rowsToMove.reverse().forEach(row => {
          targetRow.before(row);
        });
      }
      
      // Broadcast new order
      broadcastRowReorder();
      showNotification('Row reordered');
    }
    
    function broadcastRowReorder() {
      const tbody = document.querySelector('#schedule-container tbody');
      if (!tbody) return;
      
      // Only send non-subchild row order - subchildren follow their parents
      const order = Array.from(tbody.querySelectorAll('tr[data-id]:not(.subchild)'))
        .map(tr => tr.dataset.id || tr.id)
        .filter(id => id);
      
      console.log('[AD] Broadcasting row reorder:', order);
      
      channel.send({
        type: 'broadcast',
        event: 'row-reorder',
        payload: { order, source: 'ad' }
      });
    }
    
    // ===== SHARPIE / COMPLETION =====
    function toggleRowComplete(rowId, btn) {
      const isMarked = markedRows.has(rowId);
      
      if (isMarked) {
        markedRows.delete(rowId);
        hideCompletedLine(rowId);
        if (btn) {
          btn.classList.remove('marked');
          btn.innerHTML = getSharpieIcon(false);
        }
      } else {
        markedRows.add(rowId);
        showCompletedLine(rowId);
        if (btn) {
          btn.classList.add('marked');
          btn.innerHTML = getSharpieIcon(true);
        }
      }
      
      // Broadcast to producer
      channel.send({
        type: 'broadcast',
        event: 'sharpie-toggle',
        payload: { rowId, marked: !isMarked, source: 'ad' }
      });
      
      showNotification(isMarked ? 'Row unmarked' : 'Row marked complete');
    }
    
    function showCompletedLine(rowId) {
      const row = document.querySelector('tr[data-id="' + rowId + '"], tr#' + rowId);
      if (!row) return;
      
      // Check if line already exists
      let line = row.querySelector('.ad-completed-line');
      if (!line) {
        // Find first TD and add line
        const firstTd = row.querySelector('td');
        if (firstTd) {
          firstTd.style.position = 'relative';
          line = document.createElement('div');
          line.className = 'ad-completed-line';
          firstTd.appendChild(line);
        }
      }
    }
    
    function hideCompletedLine(rowId) {
      const row = document.querySelector('tr[data-id="' + rowId + '"], tr#' + rowId);
      if (!row) return;
      
      const line = row.querySelector('.ad-completed-line');
      if (line) {
        line.remove();
      }
    }
    
    // ===== DURATION EDIT =====
    function editDuration(rowId, cell) {
      // Check if already editing
      if (cell.querySelector('input')) return;
      
      const currentValue = cell.textContent.trim();
      const span = cell.querySelector('span');
      
      const input = document.createElement('input');
      input.type = 'number';
      input.className = 'duration-edit-input';
      input.value = currentValue;
      input.min = '0';
      input.step = '5';
      
      const finishEdit = () => {
        const newValue = input.value || '0';
        if (span) {
          span.textContent = newValue;
          span.style.display = '';
        } else {
          cell.textContent = newValue;
        }
        input.remove();
        
        // Broadcast change
        channel.send({
          type: 'broadcast',
          event: 'duration-change',
          payload: { rowId, duration: newValue, source: 'ad' }
        });
        
        showNotification('Duration updated to ' + newValue);
      };
      
      input.addEventListener('blur', finishEdit);
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          finishEdit();
        } else if (e.key === 'Escape') {
          input.value = currentValue;
          finishEdit();
        }
      });
      
      if (span) {
        span.style.display = 'none';
      }
      cell.textContent = '';
      cell.appendChild(input);
      if (span) cell.appendChild(span);
      input.focus();
      input.select();
    }
    
    // ===== EVENT HANDLERS FROM PRODUCER =====
    function handleFullSync(payload) {
      console.log('[AD] Full sync received:', payload);
      const data = payload.payload || payload;
      
      if (data.source === 'ad') return; // Ignore our own
      
      const { order, sharpieRows, linesHidden } = data;
      
      // Reorder rows - move each row and its subchildren
      if (order && order.length) {
        const tbody = document.querySelector('#schedule-container tbody');
        if (tbody) {
          order.forEach(rowId => {
            const row = document.querySelector('tr[data-id="' + rowId + '"], tr#' + rowId);
            if (row) {
              tbody.appendChild(row);
              
              // If this is a SUB row, also move its subchildren
              if (row.dataset.type === 'SUB') {
                const subchildren = tbody.querySelectorAll('tr.subchild[data-parent="' + rowId + '"]');
                subchildren.forEach(child => tbody.appendChild(child));
              }
            }
          });
        }
      }
      
      // Update sharpie state
      markedRows.clear();
      if (sharpieRows) {
        sharpieRows.forEach(rowId => {
          markedRows.add(rowId);
          showCompletedLine(rowId);
        });
      }
      
      // Update visibility
      if (linesHidden !== undefined) {
        progressVisible = !linesHidden;
        updateProgressUI();
      }
      
      updateStatus('synced');
      showNotification('Synced with producer');
    }
    
    function handleRowReorder(payload) {
      console.log('[AD] Row reorder received:', payload);
      const data = payload.payload || payload;
      
      if (data.source === 'ad') return;
      
      const { order } = data;
      if (!order || !order.length) return;
      
      const tbody = document.querySelector('#schedule-container tbody');
      if (!tbody) return;
      
      // Reorder rows - move each row and its subchildren
      order.forEach(rowId => {
        const row = document.querySelector('tr[data-id="' + rowId + '"], tr#' + rowId);
        if (row) {
          tbody.appendChild(row);
          
          // If this is a SUB row, also move its subchildren
          if (row.dataset.type === 'SUB') {
            const subchildren = tbody.querySelectorAll('tr.subchild[data-parent="' + rowId + '"]');
            subchildren.forEach(child => tbody.appendChild(child));
          }
        }
      });
      
      showNotification('Rows reordered by producer');
    }
    
    function handleDurationChange(payload) {
      console.log('[AD] Duration change received:', payload);
      const data = payload.payload || payload;
      
      if (data.source === 'ad') return;
      
      const { rowId, duration } = data;
      const row = document.querySelector('tr[data-id="' + rowId + '"], tr#' + rowId);
      if (!row) return;
      
      const durationCell = row.querySelector('td[data-key="duration"]');
      if (durationCell) {
        const span = durationCell.querySelector('span');
        if (span) {
          span.textContent = duration;
        } else {
          durationCell.textContent = duration;
        }
      }
      
      showNotification('Duration updated by producer');
    }
    
    function handleSharpieToggle(payload) {
      console.log('[AD] Sharpie toggle received:', payload);
      const data = payload.payload || payload;
      
      if (data.source === 'ad') return;
      
      const { rowId, marked } = data;
      
      // Find the mark button for this row
      const row = document.querySelector('tr[data-id="' + rowId + '"], tr#' + rowId);
      const btn = row?.querySelector('.ad-mark-btn');
      
      if (marked) {
        markedRows.add(rowId);
        showCompletedLine(rowId);
        if (btn) {
          btn.classList.add('marked');
          btn.innerHTML = getSharpieIcon(true);
        }
      } else {
        markedRows.delete(rowId);
        hideCompletedLine(rowId);
        if (btn) {
          btn.classList.remove('marked');
          btn.innerHTML = getSharpieIcon(false);
        }
      }
      
      showNotification(marked ? 'Row marked by producer' : 'Row unmarked by producer');
    }
    
    function handleSharpieVisibility(payload) {
      console.log('[AD] Sharpie visibility received:', payload);
      const data = payload.payload || payload;
      
      if (data.source === 'ad') return;
      
      progressVisible = !data.hidden;
      updateProgressUI();
    }
    
    function handleSyncStatus(payload) {
      console.log('[AD] Sync status received:', payload);
      const data = payload.payload || payload;
      
      isLive = data.live;
      updateStatus(isLive ? 'synced' : 'offline');
      
      if (isLive) {
        showNotification('Producer is LIVE');
      } else {
        showNotification('Producer disconnected');
      }
    }
    
    function handlePresence() {
      if (!channel) return;
      const state = channel.presenceState();
      const users = Object.values(state).flat();
      console.log('[AD] Presence:', users);
    }
    
    // ===== UI HELPERS =====
    function toggleProgress() {
      progressVisible = !progressVisible;
      updateProgressUI();
      
      // Broadcast to producer
      channel.send({
        type: 'broadcast',
        event: 'sharpie-visibility',
        payload: { hidden: !progressVisible, source: 'ad' }
      });
    }
    
    function updateProgressUI() {
      const btn = document.getElementById('sharpieToggle');
      
      if (progressVisible) {
        document.body.classList.add('show-progress');
        btn.classList.remove('lines-hidden');
      } else {
        document.body.classList.remove('show-progress');
        btn.classList.add('lines-hidden');
      }
    }
    
    function updateStatus(status) {
      const badge = document.getElementById('liveBadge');
      const text = document.getElementById('liveText');
      
      badge.classList.remove('live', 'synced', 'connecting', 'offline');
      
      switch (status) {
        case 'synced':
          badge.classList.add('synced');
          text.textContent = 'SYNCED';
          document.getElementById('loading').style.display = 'none';
          break;
        case 'connecting':
          badge.classList.add('connecting');
          text.textContent = 'CONNECTING';
          break;
        case 'offline':
          badge.classList.add('offline');
          text.textContent = 'OFFLINE';
          break;
        default:
          badge.classList.add('offline');
          text.textContent = 'OFFLINE';
      }
    }
    
    function showError(msg) {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('schedule-container').style.display = 'none';
      document.getElementById('error').style.display = 'flex';
      document.getElementById('error').querySelector('p').textContent = msg;
      updateStatus('offline');
    }
    
    function showNotification(msg) {
      const el = document.getElementById('notification');
      el.textContent = msg;
      el.classList.add('show');
      setTimeout(() => el.classList.remove('show'), 2000);
    }
    
    // Start when DOM ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  })();
  </script>
</body>
</html>
